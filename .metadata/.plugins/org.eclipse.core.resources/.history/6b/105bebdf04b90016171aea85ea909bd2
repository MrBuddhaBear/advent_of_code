package Solution;

import java.util.Arrays;
import java.util.List;

import static Solution.Day1.AbsoluteDirection.*;
import static Solution.Day1.RelativeDirection.*;

/**
 * --- Day 1: No Time for a Taxicab ---
 * 
 * Santa's sleigh uses a very high-precision clock to guide its movements, and
 * the clock's oscillator is regulated by stars. Unfortunately, the stars have
 * been stolen... by the Easter Bunny. To save Christmas, Santa needs you to
 * retrieve all fifty stars by December 25th.
 * 
 * Collect stars by solving puzzles. Two puzzles will be made available on each
 * day in the advent calendar; the second puzzle is unlocked when you complete
 * the first. Each puzzle grants one star. Good luck!
 * 
 * You're airdropped near Easter Bunny Headquarters in a city somewhere. "Near",
 * unfortunately, is as close as you can get - the instructions on the Easter
 * Bunny Recruiting Document the Elves intercepted start here, and nobody had
 * time to work them out further.
 * 
 * The Document indicates that you should start at the given coordinates (where
 * you just landed) and face North. Then, follow the provided sequence: either
 * turn left (L) or right (R) 90 degrees, then walk forward the given number of
 * blocks, ending at a new intersection.
 * 
 * There's no time to follow such ridiculous instructions on foot, though, so
 * you take a moment and work out the destination. Given that you can only walk
 * on the street grid of the city, how far is the shortest path to the
 * destination?
 * 
 * For example:
 * 
 * Following R2, L3 leaves you 2 blocks East and 3 blocks North, or 5 blocks
 * away. R2, R2, R2 leaves you 2 blocks due South of your starting position,
 * which is 2 blocks away. R5, L5, R5, R3 leaves you 12 blocks away. How many
 * blocks away is Easter Bunny HQ?
 */
public class Day1 {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		System.out.println( (-1 + 4) % 4);

	}
	
	// represents the relative direction
	enum RelativeDirection {
		LEFT,
		RIGHT
	}

	// represents the absolute direction
	enum AbsoluteDirection {
		NORTH(0),
		EAST(1),
		SOUTH(2),
		WEST(3);

		// List of absolute directions in clockwise order.
		static AbsoluteDirection[] clockwiseCompass = {NORTH, EAST, SOUTH, WEST};

		// Index of the absolute direction in the clockwise compass.
		int position;
		
		AbsoluteDirection(int position) {
			this.position = position;
		}

		// Returns the absolute direction after turning the given relative direction.
		// 
		// This works by using the clockwise compass as a reference for right or left. Turing to 
		// the right corresponds add one to the index and vice versa for left. Since the directions
		// on a compass are naturally circular, the modulo of the new index is taken to prevent
		// indexing out of bounds and 4 is added to the position initially to prevent negative
		// indexes.
		AbsoluteDirection turn(RelativeDirection relDir) {
			int index = ((position + 4) + (relDir == RIGHT ? 1 : -1)) % 4;
			return clockwiseCompass[index];
		}
	}

	// A single direction, i.e. a relative direction and a step count
	static class Direction{
		
		// the relative direction
		RelativeDirection relativeDirection;

		// the step count
		int stepCount;

		Direction(RelativeDirection relativeDirection, int stepCount) {
			this.relativeDirection = relativeDirection;
			this.stepCount = stepCount;
		}

		// relative direction getter
		RelativeDirection getRelativeDirection() {
			return relativeDirection;
		}
		
		// step count getter
		int getStepCount() {
			return stepCount;
		}
	}

	static class Document {

		// Input to my specific puzzle.
		static String INPUT = "R2, L1, R2, R1, R1, L3, R3, L5, L5, L2, L1, R4, R1, R3, L5, L5, R3, L4, L4, R5, R4, R3, L1, L2, R5, R4, L2, R1, R4, R4, L2, L1, L1, R190, R3, L4, R52, R5, R3, L5, R3, R2, R1, L5, L5, L4, R2, L3, R3, L1, L3, R5, L3, L4, R3, R77, R3, L2, R189, R4, R2, L2, R2, L1, R5, R4, R4, R2, L2, L2, L5, L1, R1, R2, L3, L4, L5, R1, L1, L2, L2, R2, L3, R3, L4, L1, L5, L4, L4, R3, R5, L2, R4, R5, R3, L2, L2, L4, L2, R2, L5, L4, R3, R1, L2, R2, R4, L1, L4, L4, L2, R2, L4, L1, L1, R4, L1, L3, L2, L2, L5, R5, R2, R5, L1, L5, R2, R4, R4, L2, R5, L5, R5, R5, L4, R2, R1, R1, R3, L3, L3, L4, L3, L2, L2, L2, R2, L1, L3, R2, R5, R5, L4, R3, L3, L4, R2, L5, R5";

		// parses the input and returns the directions in the document
		static List<Direction> getDirections() {
			Arrays.stream(INPUT.split(","))
				.map(str -> str.trim())
				.map(Document::parseDirection);
		}

		static Direction parseDirection(String dir) throws Throwable {
			int stepCount = Integer.parseInt(dir.substring(1));
			char relDir = dir.charAt(0);
			switch (relDir) {
				case 'R' :
					return new Direction(RIGHT, stepCount);
				case 'L' :
					return new Direction(LEFT, stepCount);
				default :
					throw new Throwable("Unable to parse " + dir + " into direction.");
			}
		}
	}

}
